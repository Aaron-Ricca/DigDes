\section{Examples}


% ==================== FILP FLOP ========================
    \subsection{Flip flop}
    \begin{lstlisting}[language=VHDL, escapeinside={(*@}{@*)}]
entity d_ff_rst is
    port(
        clk : in bit;
        rst : in bit;
        d : in bit;
        q : out bit
        );
end d_ff_rst;
    
architecture behavioral of d_ff_rst is
begin
    register : process(clk, rst)
            -- d fehlt in Sens.list
    begin   -- Nur clk und Reset
            -- aktivieren Prozess
        if (rst = '1') then
            -- Asynchroner Reset
            q <= '0';
            -- wird zuerst abgearbeitet
        elsif (clk(*@'@*)event and clk = '1') then
        (*@\setlength{\fboxsep}{1pt}\colorbox{yellow}{\strut\textbf{\textcolor[rgb]{0.0,0.4,0.2}{-- Sintassi per la detezione del fianco salita del clock}}}@*)
            q <= d; -- Synchroner Teil
        end if; -- Kein abschliessendes
        -- else: in allen anderen
    end process; -- FÃ¤llen wird gespeichert.
end behavioral;
    \end{lstlisting}


% ==================== LATCH ========================
    \subsection{Latch}
        \begin{lstlisting}[language=VHDL]
process_3 : process(s,a,b)
    begin if s = '0' then
        oup <= a;
    elsif s = '1' then
        oup <= b;
    end if;
end process;
        \end{lstlisting}

        
% ==================== GENERIC COUNTER ========================
    \subsection{Generic Counter}
        \begin{lstlisting}[language=VHDL, escapeinside={(*@}{@*)}]
            -- Dev'esserci la libreria ieee.math_real.all;
entity counter_generic is
    generic(CNT_MAX : natural := 127);
    port(
        clk, rst, ena  : in std_logic;
        count : out std_ulogic_vector
        (natural(ceil(log2(real(CNT_MAX + 1)))) - 1 downto 0));
    end counter_generic;
        \end{lstlisting}

        
% ==================== CLOCKDIVIDER ========================
    \subsection{Clock Divider}
        \begin{lstlisting}[language=VHDL, escapeinside={(*@}{@*)}]
entity clockdivider is
    generic(DIV_FACTOR : natural := 128);
    port(
        clk, rst, ena : in std_ulogic;
        clk_out : out std_ulogic);
end entity clockdivider;
architecture behavioral of clockdivider is
    -- pro Register ein present- und next-signal
    signal cnt_present, cnt_next : natural range 0 to (DIV_FACTOR - 1);
    signal tick_present, tick_next : std_ulogic;

begin
        \end{lstlisting}

% ==================== TEST BENCH ========================
    \subsection{Test bench (tb)}
        \begin{lstlisting}[language=VHDL, escapeinside={(*@}{@*)}]
-- Library declarations
library ieee
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- entity declarations
entity exor_tb is
end exor_tb;

-- architecture declarations
architecture tb of exor_tb is
    -- constant declarations
    constant sim_cyc : time := 10 ns;
    -- signal declarations
    signal tb_a, tb_b : std_ulogic;
    signal tb_y: std_ulogic;
    -- Component declarations
    component xor2
        port(
        xor2_a, xor2_b : in std_ulogic;
        xor2_y
        : out std_ulogic);
    end component;
    -- configuration
    for all : xor2 use entity work.xor2(behavioral);

    begin
        -- instance assignments
        dut : xor2
            port map(
            xor2_a => tb_a,
            xor2_b => tb_b,
            xor2_y => tb_y
            );

        -- Signal assignments for stimuli
        Stimuli : process
            variable tb_in_vec: std_ulogic_vector(2 - 1 downto 0);
        begin
            for i in 0 to (2 ** 2) - 1 loop
            tb_in_vec := std_ulogic_vector(to_unsigned(i, 2));
            tb_a <= tb_in_vec(1);
            tb_b <= tb_in_vec(0);
            wait for sim_cyc;
            end loop;
            wait;
        end process;

        -- Evaluation of responses
        Response : process
        begin
            wait for (sim_cyc - 1 ns);
            assert (tb_y = '0') report "error at vector 00" severity error;
            wait for sim_cyc;
            assert (tb_y = '1') report "error at vector 01" severity error;
            wait for sim_cyc;
            assert (tb_y = '1') report "error at vector 10" severity error;
            wait for sim_cyc;
            assert (tb_y = '0') report "error at vector 11" severity error;
        end process;
end tb;
            \end{lstlisting}

% ==================== KOMPILIERBARER VHDL-Code ========================
    \subsection{Compilable VHDL Code}
        \begin{lstlisting}[language=VHDL]
            library ieee; 
use ieee.std_logic_1164.all;     
 
 
entity strukturell_15 is      
 port( 
  clk      : in  std_ulogic;   
  rst     : in  std_ulogic; 
  clk_1Hz  : in std_ulogic; 
  selector : in  Std_ulogic; 
  result   : out std_ulogic_vector(7 downto 0) 
 ); 
end entity strukturell_15; 
 
architecture RTL of strukturell_15 is    
 component mux_13 
  port( in_1 : in  std_ulogic_vector(7 downto 0); 
   in_2 : in  std_ulogic_vector(7 downto 0); 
   sel  : in  std_ulogic; 
   oup  : out std_ulogic_vector(7 downto 0) 
  ); 
 end component mux_13; 
 
 component counter_13 
  port( clk      : in  std_ulogic; 
   rst      : in  std_ulogic; 
   count_out : out std_ulogic_vector(7 downto 0)); 
 end component counter_13; 
 
 signal value_1      : std_ulogic_vector(7 downto 0);  
 signal value_2      : std_ulogic_vector(7 downto 0); 
 
begin 
 counter : counter_13     
  port map( clk        => clk,   
    rst       => rst,  
      count_out  => value_1);     
 
 trigger_15sec : counter_13 
  port map( clk        => clk_1Hz,     
         rst       => rst, 
         count_out  => value_2); 
 
 mux : mux_13 
  port map( in_1   => value_1,     
         in_2   => value_2, 
         sel    => selector, 
         oup    => result 
  ); 
end architecture RTL;
        \end{lstlisting}

% ==================== sequenzielle schaltung - zustandautomaten ========================
    \subsection{sequenzielle schaltung - zustandautomaten}
        \begin{lstlisting}[language=VHDL]
library ieee; 
use ieee.std_logic_1164.all;      
 
entity lift is 
 port(         
  clk       : in  std_ulogic; 
  nrst      : in  std_ulogic; 
  LS_1_edge : in  std_ulogic; 
  LS_1      : in  std_ulogic;     -- Lichtschranke_1 
  LS_2      : in  std_ulogic;     -- Lichtschranke_2 
  down      : out std_ulogic; 
  up        : out std_ulogic 
 ); 
end lift; 
 
architecture behavioral of lift is 
 type state_type is (reset_state, state_up, state_down);  
 
 signal present_state : state_type; 
 signal next_state    : state_type;     
 
begin 
 Output_logic : process(present_state)    
 begin         
  up   <= '0';                 
  down <= '0'; 
  case present_state is 
   when state_up => 
    up <= '1'; 
   when state_down => 
    down <= '1'; 
   when others => null;    
  end case; 
 end process; 
 
 Next_state_logic : process(present_state, LS_1, LS_2, LS_1_edge) 
 begin 
  next_state <= reset_state;       
  case present_state is 
   when reset_state => 
    if ((LS_1_edge = '1') and (LS_1 /= LS_2)) then 
     next_state <= state_up; 
    elsif ((LS_1_edge = '1') and (LS_1 = LS_2)) then 
     next_state <= state_down;  
    end if; 
   when state_up => 
    if ((LS_1_edge = '1') and (LS_1 = LS_2)) then 
     next_state <= state_down; 
    else 
     next_state <= state_up; 
    end if; 
   when state_down => 
    if ((LS_1_edge = '1') and (LS_1 /= LS_2)) then 
     next_state <= state_up;   
    else       
     next_state <= state_down;   
    end if;      
     when others => null;            
  end case;       
 end process; 
 
 registers : process(nrst, clk)    
 begin        
  if (nrst = '0') then    
   present_state <= reset_state; 
  elsif rising_edge(clk) then   
   present_state <= next_state; 
  end if; 
 end process; 
 
end behavioral; 
 -- Kompakte Version 
architecture compact of lift is 
 subtype state_type is std_ulogic_vector(1 downto 0); 
 signal present_state, next_state : state_type; 
 
 constant reset_state : state_type := "00"; 
 constant state_down  : state_type := "10"; 
 constant state_up    : state_type := "01"; 
 
begin 
 Output_logic : (down, up) <= present_state; 
 
 Next_state_logic : process(LS_1, LS_2) 
 begin 
  if (LS_1 = LS_2) then 
   next_state <= state_down; 
  else 
   next_state <= state_up; 
  end if; 
 end process; 
 
 registers : process(nrst, clk) 
 begin 
  if (nrst = '0') then 
   present_state <= reset_state; 
  elsif rising_edge(clk) then 
   if (LS_1_edge = '1') then     
    present_state <= next_state; 
   end if; 
  end if; 
 end process; 
 
end architecture compact;
        \end{lstlisting}