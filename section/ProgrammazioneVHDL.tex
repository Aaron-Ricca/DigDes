\section{Programmazione VHDL}
% =========================================== INTRODUZIONE =========================================
    \subsection{Introduzione}
        In VHDL sono vietati gli if e le variabili al di fuori dei processi. É anche vietato l'uso di "Feedback" in quanto creano cose brutte.
% =========================================== LIBRARY =========================================
    \subsection{Library}
        Una libreria puo contenere componenti e o pachetti. I componenti sono descrizione di circuiti e realizzazione specifiche,
        vengono memorizzati nella libreria in modo da poter essere riutilizati piu volte e da piu progettisti contemporaneamente.\\
        I blocchi di codice di una libreria sono memorizzati in forma compilata, direttamente eseguibile.\\
        Contenuto di una libreria: Components, Packages, Functions, Procedures, Declarations.
        \begin{lstlisting}[language=VHDL]
library ieee; 
use ieee.std_logic_1164.all; -- CPP: using namespace std;
use ieee.numeric_std.all; -- X operazioni aritmetiche x vettori
use ieee.math_real.all; -- X operazioni aritmetiche x scalari
        \end{lstlisting}


% =========================================== ENTITY =========================================
    \subsection{entity dichiarazione}
        L'entità descrive il componente del progetto.
        In primo luogo l'entità descrive l'interfaccia (schnittstelle) del componente.
        \begin{lstlisting}[language=VHDL]
entity <entity name> is
    port (
        {<port_name> : <mode> <type>;} -- <mode> = in | out | inout
    );
end <entity name>;
        \end{lstlisting}

% =========================================== ARCHITECTURE ======================================
    L'architettura descrive il comportamento del componente, come funziona e come è realizzato.
    \subsection{architecture}
        \begin{lstlisting}[language=VHDL, numberstyle=\tiny\color{gray}\highlightlines{1,7,8,9}{green}]
architecture <architecture_type> of <entity_name> is
    [type_declaration]
        [component_declaration]
        [subtype_declaration]
        [constant_declaration]
        [signal_declaration]
begin
    -- codice di architettura
end <architecture_type>;
        \end{lstlisting}


% ========================================= COMPONENTI =========================================
    \subsection{component dichiarazione}
        I componenti sono utilizzati per definire le porte di un'entità, in modo da poterla utilizzare in altre entità.
        \begin{lstlisting}[language=VHDL]
component <component_name>
    port (
        {<port_name> : <mode> <type>;}
    );
end component <component_name>;
        \end{lstlisting}

        
% =========================================== PORT MAPPING ======================================
        \subsection{Port mapping}
            Il port mapping è utilizzato per collegare le porte dell'entità con i segnali dell'architettura.
            \begin{lstlisting}[language=VHDL]
U1: entity_name
    port map (
        <port_name> => <signal_name>,
        <port_name> => <signal_name>
    );
            \end{lstlisting}

% ---------------------------------------- EXAMPLE ------------------------------------
            \subsubsection{Esempio}
            \begin{lstlisting}[language=VHDL, escapeinside={(*@}{@*)}, numberstyle=\tiny\color{gray}\highlightlines{3,4,5,6,19,20,21,22,23,24}{yellow}, numberstyle=\tiny\color{gray}\highlightlines{10,11,12,13,26,27}{green}]
architecture structural of half_adder is
    -- dichiarazione del componente xor2
    component xor2
        port (
            in1, in2 : in bit;
            oup      : out bit
        );
    end component;

    -- dichiarazione del componente and2
    component and2
        port (
            in1, in2 : in bit;
            oup      : out bit
        );
    end component;

    begin
    -- instantiation of ocmponents XOR2 and AND2
    (*@\setlength{\fboxsep}{1pt}\colorbox{yellow}{\strut\textbf{\textcolor[rgb]{0.0,0.4,0.2}{-- Mappatura esplicita}}}@*)
    U1 : xor2
        port map (
            in1 => q,
            in2 => p,
            oup  => s
        );
    (*@\setlength{\fboxsep}{1pt}\colorbox{yellow}{\strut\textbf{\textcolor[rgb]{0.0,0.4,0.2}{-- Mappatura implicita}}}@*)
    U2 : and2
        port map (p, q, s) -- L'ordine delle porte segue quello della dichiarazione del componente!
            \end{lstlisting}

        
% =========================================== HIERARCHIC LEVELS ======================================
        \subsection{Hierarchie Level}
            \begin{minipage}[t]{\columnwidth}
            \vspace{0pt}  %<-- ensures top alignment
                \includegraphics[width=\linewidth]{Images/HierarchienLevel.png}
            \end{minipage}

% ============================================ TIPI =========================================
    \subsection{Tipi}
        \begin{itemize}
            \item \texttt{<architecture\_type>} = \texttt{Behavioral} \textbar{} \texttt{Structural} \textbar{} \texttt{RTL} \textbar{} \texttt{Dataflow} \textbar{} \texttt{Tb} \textbar{} \texttt{(...)} 
            \item \texttt{<mode>} = \texttt{in} \textbar{} \texttt{out} \textbar{} \texttt{inout}
            \item \texttt{<type>} = \texttt{bit} \textbar{} \texttt{bit\_vector} \textbar{} \texttt{std\_}\textcolor{red}{u}\texttt{logic} \textbar{} \texttt{std\_}\textcolor{red}{u}\texttt{logic\_vector} \textbar{} \texttt{integer} \textbar{} \texttt{boolean}
        \end{itemize}
        


% ---------------------------------------- <ARCHITECTURE TYPES> ------------------------------------
        \subsubsection{\texttt{<architecture\_type>}}
            \textbf{Behavioral}: si occupa di descrivere il comportamento del circuito, senza preoccuparsi della struttura fisica. Alto livello di astrazione concetto Wahrheitstabelle.
            \begin{lstlisting}[language=VHDL]
if rising_edge(clk) then
    if A = '1' then
    Y <= B;
    end if;
end if;
            \end{lstlisting}

            \textbf{Structural}: si occupa di descrivere la struttura fisica del circuito, utilizzando componenti e connessioni tra di essi. Medio livello di astrazione.
            \begin{lstlisting}[language=VHDL]
U1: and_gate port map (A => A, B => B, Y => Y1);
U2: or_gate  port map (A =1, B => C, Y => Y);
            \end{lstlisting}

            \textbf{RTL}: si occupa di descrivere il circuito a livello di registro e logica combinatoria, utilizzando registri e porte logiche. Basso livello di astrazione.Concetto Boolsche Ausdrucke.
            \begin{lstlisting}[language=VHDL]
if rising_edge(clk) then
    reg1 <= A and B;
    reg2 <= reg1 xor C;
end if;
            \end{lstlisting}

            \textbf{Dataflow}: si occupa di descrivere il circuito a livello di flusso di dati, utilizzando porte logiche e segnali. Basso livello di astrazione.
            \begin{lstlisting}[language=VHDL]
Y <= (A and B) or (not C);
            \end{lstlisting}

            \textbf{Tb}: si occupa di descrivere il circuito a livello di testbench, utilizzando segnali di test e componenti di test.
            \begin{lstlisting}[language=VHDL]
A <= '0'; wait for 10 ns;
A <= '1'; wait for 10 ns;
assert (Y = expected_value) report "Test failed" severity error;
            \end{lstlisting}

% ---------------------------------------- <TYPES> ------------------------------------
        \subsubsection{\texttt{<type> (dichiarazione: segnali, variabili, ...)}}
        \begin{minipage}[t]{0.49\columnwidth}
        Come vanno dichiarati tutti i segnali utilizzati internamente all'archittetura.\\Nella sintesi del codice, é vietato inizzializzare i segnali nella dichiarazione!
        \texttt{bit}, \texttt{bit\_vector}, \texttt{std\_logic}, \texttt{std\_logic\_vector}, \texttt{std\_ulogic}, \texttt{std\_ulogic\_vector}, \texttt{integer}, \texttt{boolean}\\
        \end{minipage}\begin{minipage}[t]{0.49\columnwidth}
        \vspace{0pt}  %<-- ensures top alignment
            \includegraphics[width=\linewidth]{Images/ConversionTypeTable.png}
        \end{minipage}
        \begin{itemize}
        \setlength\itemsep{0pt}
            \item \texttt{std\_logic}: rappresenta un singolo bit con valori \texttt{'0'}, \texttt{'1'}.
            \begin{lstlisting}[language=VHDL]
signal C : std_logic;
            \end{lstlisting}
            \item \texttt{std\_ulogic}: rappresenta un singolo bit con valori \texttt{'0'}, \texttt{'1'}, \texttt{'Z'} (alta impedenza) e \texttt{'X'} (indeterminato).
            \item \texttt{integer}: rappresenta un numero intero, con valori compresi tra $-2^{31}$ e $2^{31}-1$ (è necessario definire l'intervallo di utilizzo).
            \begin{lstlisting}[language=VHDL]
signal G : integer range 0 to 255; -- intervallo di utilizzo
            \end{lstlisting}
            \item \texttt{boolean}: rappresenta un valore booleano, con valori \texttt{true} e \texttt{false}.
        \end{itemize}

        \begin{center}
            \begin{adjustbox}{max width=\columnwidth}
                \begin{tabular}{|l|l|p{6cm}|c|}
                    \hline
                    \multicolumn{1}{|c|}{\shortstack{\textbf{Logik}\\\textbf{-wert}}} & 
                    \multicolumn{1}{c|}{\textbf{Bedeutung}} & 
                    \multicolumn{1}{c|}{\textbf{Verwendung}} & 
                    \multicolumn{1}{c|}{\shortstack{\textbf{Für Logik}\\\textbf{Synthese}}} \\
                        \hline
                        \verb|'U'| & Uninitialized   & Signal ist im Simulator noch nicht initialisiert. In der Hardware ist das Signal unbekannt. Typisch für nicht initialisierte Speicherstelle nach Start-up. & Nein \\
                        \hline
                        \verb|'X'| & Undefined       & Signal ist dem Simulator unbekannt. Typisch für Treiberkonflikte, d.h. ein Signal wird von mehr als einer Quelle getrieben. In der Welt der Hardware kommt dies vor allem bei Buskonflikten vor. & Nein \\
                        \hline
                        \verb|'0'| & Strong zero     & Low Pegel eines Standardausganges. Regelfall für Hardware „0“ Pegel. & Ja \\
                        \hline
                        \verb|'1'| & Strong one      & High Pegel eines Standardausganges. Regelfall für Hardware „1“ Pegel. & Ja \\
                        \hline
                        \verb|'Z'| & High Impedance  & Signalausgang von Leitung entkoppelt. Typisch für Hochimpedanz Ausgang eines Three-State Treibers bei bidirektionalen Bussen. & Ja \\
                        \hline
                        \verb|'L'| & Weak zero       & Low Pegel eines schwachen Treiberausgangs. Typisch für ein Signal, das mit einem pull-down Widerstand auf Low Potenzial gezogen wird. & Nein \\
                        \hline
                        \verb|'H'| & Weak one        & High Pegel eines schwachen Treiberausgangs. Typisch für ein Signal, das mit einem pull-up Widerstand auf High Potenzial gezogen wird. & Nein \\
                        \hline
                        \verb|'W'| & Weak unknown    & Simulator erkennt Treiberkonflikt. Dieser Fall ist analog zu \verb|'X'| mit dem Unterschied, dass der Treiberkonflikt hier durch schwache Treiber verursacht wird. & Nein \\
                        \hline
                        \verb|'-'| & Don’t Care      & Logikzustand des Ausgangssignals ist bedeutungslos. Existiert nur in der Schaltungssynthese und wird für Logikminimierung gebraucht. & Nein \\
                        \hline
                \end{tabular}
            \end{adjustbox}
        \end{center}


% ============================================ GENERICS =========================================
    \subsection{Generics}
        \begin{itemize}
            \item VHDL può passare parametri a un modello
            \item Dichiarato nella descrizione dell'interfaccia.
            \item generic dev\textquotesingle essere dichiarato in entity e in component 
        \end{itemize}
        \begin{lstlisting}
    entity counter_generic ist
        generic(CNT_MAX : natural := 127); -- generic dichiarato
        port(
            clk, rst, ena  : in std_ulogic;
            count : out natural range 0 to CNT_MAX -1);
    end counter_generic;
        \end{lstlisting}
        
% ============================================ PARALLEL SIGNAL =========================================
    \subsection{Nebenläufige Signalzuweisungen "y<=x"}
        \subsubsection{Definizione dei segnali}
            \begin{lstlisting}[language=VHDL]
singal <signal_name> :{,<singal_name>} : <type>
[:= inizianol_value]; -- inizial_value é opzionale
            \end{lstlisting}
    
    % ------------------------------ UNCONDITIONAL -----------------
        \subsubsection{Unbedingte Signalzuweisung}
            L'assegnazione dei segnali é incondizionata, quindi indipendente.
            \begin{lstlisting}[language=VHDL]
y <= '0';
y <= a and b;
            \end{lstlisting}
    
    % ------------------------------ CONDITIONAL -----------------
        \subsubsection{Bedingte Signalzuweisung}
            L'assegnazione dei segnali é eseguita in modo sequenziale, si controlla una condizione e se corretta si assegna il valore, sennó si procede con la prossima condizione.
            \begin{lstlisting}[language=VHDL]
y <= '0' when a = '1' else 
        '1' when a = '0';
            \end{lstlisting}
    
    % ------------------------------ SELECTIVE -----------------
        \subsubsection{Selektive Signalzuweisung}
            L'assegnazione dei segnali é eseguita in modo selettivo, viene selezionata il valore in base alla condizione.
            \begin{lstlisting}[language=VHDL]
with s select y <=
    '0' when "00", -- quando s = "00" y <= '0'
    '1' when "01", -- quando s = "01" y <= '1'
    'Z' when "10", -- quando s = "10" y <= 'Z'
    'X' when others; -- quando s =  altro y <= 'X'
            \end{lstlisting}
    
    % ------------------------------ AGGREGATE -----------------
        \subsubsection{aggregate}
            L'aggregazione dei segnali permette di aggregare segnali individuali in un unico segnale.
            \begin{lstlisting}[language=VHDL]
y <= (a, b, '1', '0'); -- Assegnazione implicita
y <= (0 => '0', 1 => '1', 2 => b, others => a); -- Assegnazione esplicita (<posizione_vettoriale> => <valore>)
            \end{lstlisting}
    
    % ------------------------------ CONCATENATE -----------------
        \subsubsection{concatenate}
            La concatenazione dei segnali permette di concatenare segnali in un unico segnale.
            \begin{lstlisting}[language=VHDL]
y <= v_1 & v_2;
            \end{lstlisting}


% ========================================= PROCESSI =========================================
    \subsection{Nebenläufige Prozesse}
        Solo all'inerno dei processi é possibile utilizzare le variabili e le istruzioni sequenziali.\\
        I processi sono "Nebenläufige" di conseguenza iniziano ad essere eseguiti in concorrenza. Ma all'interno il codice viene eseguito normalmente (istruzioni sequenziali, sequenzialmente. istruzioni parallele in modo parallelo).\\
        I processi sono sezioni di codice che vengono eseguite ogni volta che un \textcolor{red}{Segnale sensibile} nella lista sensibile (Sensitivitätliste) cambia di stato.\\         % Inizia un codice blocco, con colori VHDL (vedi definizione in DigDes.tex), escape inside is used to use external commandstf
        Nota: se un segnale usato in un processo non è nella lista di sensibilità, il suo valore corrisponde al valore durante la chiamata del processo/indefinito nel caso cambia in concomitanza.\\
        \begin{lstlisting}[language=VHDL, escapeinside={(*@}{@*)}, numberstyle=\tiny\color{gray}\highlightlines{3,4,5,6,7}{green}]
process ((*@\textcolor{red}{clk, reset}@*))
    begin
        if reset = '1' then
            -- inserisci il codice da eseguire in caso di reset
        elsif rising_edge(clk) then
            -- inserisci il codice da eseguire ad ogni fronte di salita del clock
        end if;
    end process;
        \end{lstlisting}
    
    % ------------------------------ SEQUENZIELLE ANWEISUNGEN IM PROZESSE -----------------
        \subsubsection{sequenzielle Anweisungen im Prozesse}
            Le istruzioni che vengono eseguite strettamente sequenziali all'interno di un processo sono:
            \begin{lstlisting}[language=VHDL]
-- struttura if else:
if condition_a then
    {sequential statements}
elsif condition_b then
    {sequential statements}
else
    {sequential statements}
end if;


-- struttura case when:
case expression is
    when choice_a => {sequential statements}
    when choice_b => {sequential statements}
    when others => {sequential statements}
end case;
            \end{lstlisting}
    
    % ------------------------------ Eigenschaften nebenläufiger Prozesse -----------------
        \subsubsection{Eigenschaften nebenläufiger Prozesse}
        Le proprietà più importanti, ovvero le estensioni rispetto alle assegnazioni di segnale, possono essere così riassunte:
            \begin{itemize}
                \item I processi possono assegnare due o più segnali contemporaneamente.
                \item L'elaborazione delle informazioni per l'assegnazione dei segnali avviene in una sequenza di comandi che vengono eseguiti uno dopo l'altro (procedurale).
                \item I processi permettono l'uso di variabili per la memorizzazione temporanea dei valori dei segnali.
                \item Grazie all'uso delle liste di sensibilità è garantito un miglior controllo sulle condizioni di esecuzione della parte di codice.
            \end{itemize}
    
    % ------------------------------ Variablen in nebenläufigen Prozessen -----------------
        \subsubsection{Variablen in nebenläufigen Prozessen}
        Le variabili offrono due opzioni utili nei processi:
            \begin{itemize}
                \item Accesso a un valore aggiornato all'interno del processo stesso.
                \item Preparazione di un'espressione di controllo, ad esempio per un "case when".
            \end{itemize}
            Le variabili sono dichiarate all'interno dei processi e sono visibili esclusivamente all'interno degli stessi.
            Il valore assegnato può essere letto immediatamente.\\
            L'assegnazione di valore a una variabile avviene con l'operatore :=, a differenza dell'assegnazione ai segnali che utilizza <=.
        \begin{lstlisting}[language=VHDL]
variable <var_name> {,var_name}: <type> [:= expression];
        \end{lstlisting}


% ========================================= MODELLING TEMPORAL BEHAVIOUR =========================================
        \subsection{Modellazione del Comportamento Temporale}
            \begin{itemize}
                \item \textbf{Event Queue}: I simulatori utilizzano una coda degli eventi per elaborare gli eventi in ordine cronologico.
                \item \textbf{Modello Delta-Time}: Modello funzionale (nessun ritardo reale). Introduce un ritardo infinitesimale (cicli delta). Separa causa ed effetto nelle forme d\textquotesingle onda, anche se appaiono simultanei.
                \item \textbf{Ritardo di Trasporto}: Modella il ritardo fisico reale.\\
                Sintassi: \texttt{B <= transport A after tp;}\\
                Tutti i cambiamenti di segnale (inclusi i glitch) vengono propagati.
                \item \textbf{Ritardo Inerziale (default)}: Modella il filtraggio dei glitch nei circuiti reali.\\
                Sintassi: \texttt{B <= A after tp;}\\
                Gli impulsi brevi (inferiori al tempo di ritardo) vengono ignorati.
            \end{itemize}
